---
layout: docs
nav: docs
title: Accio concepts
---

From the users' point of view, the whole Accio world gravitates around a few concepts: operators, workflows and runs.

## Operators

*Operators* are the basic building block of Accio.
They can be viewed as a function in a program: given some inputs, they produce some outputs.
Each operator comes with a very clearly defined interface: it defines the inputs it consumes and the outputs it produces, using a type system provided by Accio.
Inputs and outputs are sometimes referred to as *ports*.
Inputs may be defined as optional (i.e., the operator can be executed even if the input is not defined) or have a default value (i.e., this default value will be used if the input is not defined).
Input and outputs ports have a type; it allows the engine to enforce values are correct before running operators.
Outputs are always defined.
Outputs generated by an execution of an operator are called *artifacts*.
Operators need to be implemented by developers, but thanks to workflows, they can be later used even by non-developers.

Operators should be stateless.
They are always executed on a single machine, this is the basic execution unit.
They provide some resource constraints on the number of CPUs, the quantity of RAM and disk space they need to execute properly;
they are guaranteed to be allocated at least these resources and must ensure not to overflow them.

Operators have a name, which must be unique across all operators registered in Accio.
They belong to a category and have a description, which is used to generate built-in documentation.

Generally speaking, operators are assumed to be deterministic.
It means that given some inputs, they are expected to produce the exact same outputs at each execution.
We support randomness through *unstable operators*.
Operators can be defined as unstable.
This unstable status can be defined depending on some inputs, but should be known before actually executing the operator.
Unstable operators are allowed to used a seed they have access to through the operator execution context.
This seed can be considered as an additional input and should be their only source of randomness.
It means that given **a set of inputs and a seed**, unstable operators are expected to produce the exact same outputs at each execution.

## Workflows

A *workflow* is a directed acyclic graph, whose nodes are instances of operators.

![Example workflow](../images/workflow.png)

The above workflow is formed of four nodes, each with its own inputs (in orange) and outputs (in purple).
The `Source` node is the root node (i.e., it has no input from another node).
It accepts one input, `uri` and produces one output, `data`.
This output is then consumed as an input by nodes `Geo-I`, `Coverage` and `Distortion`.
It becomes clear that some inputs are filled from the output of another node (e.g, the `data` input of `Geo-I`), while some other are directly specified through a constant (e.g, the `epsilon` input of `Geo-I`).
Ports inside a workflow are generally referred to with their absolute name, formed of the node name and the port name, separated by a slash (`/`), e.g., `Geo-I/data`.

When specifying workflows, you essentially define a list of nodes and how to connect them.
Each node is an instance of a given operator, has a name and some inputs.
The name of a node is by default the name of the operator it is an instance of.
However, you can freely give a node another name.
It is even required if you want to have multiple instances of the same operator inside a workflow, as node names are unique.
Each node also specifies its inputs, e.g., directly with a constant value or by connecting it to the output port of another node.

Workflows can have parameters, which are values specified only at run time by the user.
Parameters can be thought as workflow-level inputs.
They have a name, a type and possibly a default value.
They allow the user to vary the value of one or several ports that take their value from a given parameter.
It means a given parameter can be used by multiple ports, though they obviously need to be of the same data type.

When executed, workflows collect the artifacts generated by every operator inside the graph.
They also collect some execution metrics, that are not directly generated by the operators but instead gathered by profilers.
These metrics are used to provide additional information about the execution, such as the duration or the memory consumption.

While operators need to be implemented by developers, workflows can be defined very simply thanks to the [workflow definition language](workflow-dsl.html).

## Runs

A run defines is a particular instantiation of a workflow, where all required parameters are defined with a single value.
When experimenting, you may be in the situation where you want to test many parametrization of a given workflow.
Thankfully, Accio provides an easy way to perform this, via a parameter sweep.
In this case, a parent run will be created to hold a reference to several children runs, the latter being the ones that will actually executed.

Every run is identified by a globally unique run identifier, which is required to monitor its state or access its results.

Runs can also be defined thanks to the [run definition language](run-dsl.html).
This small DSL provides an easy way to define a single run as well as a parameter sweep generating hundreds of runs.
