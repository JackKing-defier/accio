---
layout: docs
title: Architecture
weight: 10
---

This section provides a system-oriented view over the Accio architecture.
Reading this section should give a understanding the various parts Accio is made of, but is not required for just using it.

## Overview

Here is the big picture about the components of Accio and the way they interact.

![Architecture overview](../../images/architecture.png)

The most important component the **Accio agent**.
Agents are processes in charge of handling users' wills.
Accio is designed around a very simple architecture, where there is no master or slave process.
One or several agents can be launched and will answer users' requests.
It is made possible because agents are stateless; persistent state is managed by storage and state manager plugins, with which agents interact.
Agents speak the [Thrift protocol](https://thrift.apache.org/), which provides an IDL to define typed messages and RPC services.
Users use the **Accio client** to communicate with the agent, which is a CLI application.

The **Accio gateway** is a simple server that speak the HTTP protocol.
It basically make the translation between Thrift and HTTP.
For now, it only provides a read-only access to Accio, meaning it is not possible to create runs or workflows through it.
It also optionally comes with a Web interface, allowing to browse Accio data in a convenient way.
This component is optional, although recommended because it greatly simplifies the usage of Accio, especially for non-technical users.

Finally, an **Accio executor** is a process launched on a worker node that will actually execute operators.
Executors are responsible for downloading data needed by an operator, processing it according its inputs and then upload produced data.
They communicate with agents to inform them of their progress, which allows to have almost real-time feedback on run execution.
It is important to note that there is no resident Accio process running on worker nodes, waiting for requests from the agent.
Instead, executors are dynamically launched and killed with an orchestration system, such as Kubernetes or Nomad.
We rely on existing and battle-proofed technology to launch and monitor executors, allowing Accio to focus on its specificity: workflows management.
Moreover, it allows Accio to be easily integrated into an existing multi-tenant infrastructure.

## Plugins

All the white boxes in the above schema represent pluggable parts, that can be easily swapped.
Accio comes with several implementations for each of them, allowing a system administrator to fine tune a cluster according to specific needs.
It also provides for each of them a "local" version that can be used to quickly bootstrap a single-node Accio instance, ideal for development or testing.

**Scheduler** plugins control lifecycle of executors.
It is provided by orchestration system such as Mesos, Kubernetes or Nomad.

**Storage** plugins provide persistent storage capabilities for data such as workflows and runs.
It could an SQL database such as MySQL or PostgreSQL or a distributed database such as Cassandra or Elasticsearch.

**State manager** plugins provide short-lived storage capabilities for data such as run progress.
It also provides a solution for inter-process locking, that is used by Accio agents to synchronize.
It could be a generic key/value store such as Consul or Redis, or a system specifically designed for coordination such as Zookeeper.

**Filesystem** plugins provide a way to read and write persistent data generated by the execution of operators that would otherwise be lost, as executors are sandboxed.
It is typically used to store datasets produced by operators.
It can be a Posix filesystem, a distributed filesystem such as GlusterFS, or a blob store such as S3.
Filesystems provide both read and write capabilities.
Unlike other plugins, several filesystem plugins may be active on a single cluster, allowing to read from and write to a variety of locations.
